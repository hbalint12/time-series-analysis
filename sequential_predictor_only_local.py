# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13ucLln-ULSgNbxG7U250ZABcWGWHFJbD
"""

import time
import math
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
from datetime import timedelta, date


def loadFromFile(fileName):
  try:
    df = pd.read_csv(fileName)
    df = df.dropna()
    return df
  except:
    print("Exception: Could not load data from file")

def plotStockPrice(df):
  try:
    plt.style.use('fivethirtyeight')
    plt.figure(figsize=(16,8))
    plt.title('Close Price History')
    plt.plot(df['Close'])
    plt.xlabel('Date', fontsize=18)
    plt.ylabel('Close Price USD', fontsize=18)
    plt.show()
  except:
    print('Exception: Dataframe could not be plotted')

def filterDataOnClosingPrice(df):
  try:
    data = df.filter(['Close'])
    return data
  except:
    print('Exception: Data could not be filtered on Close column')

def getValuesFromDataFrame(data):
  try:
    return data.values
  except:
    print('Exception: Data does not have values property')

def scaleDataset(dataset, scaler):
  try:
    scaled_data = scaler.fit_transform(dataset)
    return scaled_data
  except:
    print('Exception: Data could not be scaled')

def defineTrainingDataLength(dataset):
  try:
    training_data_len = math.ceil(len(dataset) * .8)
    return training_data_len
  except:
    print('Exception: Training data length could not be created')

def createTraingAndTestDataWithSlidingWindow(dataset, scaled_data, sliding_window_length, training_data_len):
  try:
    train_data = scaled_data[0:training_data_len, :]
    x_train = []
    y_train = []
    for i in range(sliding_window_length, len(train_data)):
      x_train.append(train_data[i-sliding_window_length:i,0])
      y_train.append(train_data[i,0])
    x_train, y_train = np.array(x_train), np.array(y_train)
    x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
    test_data = scaled_data[training_data_len - sliding_window_length:,:]
    x_test = []
    y_test = dataset[training_data_len:,:]
    for i in range(sliding_window_length, len(test_data)):
      x_test.append(test_data[i-sliding_window_length:i,0])
    x_test = np.array(x_test)
    x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))
    return x_train, y_train, x_test, y_test
  except:
    print('Exception: Training and test data could not be created with sliding window')


def createLSTMModel(x_train,numOfUnits,setOptimizer):
  try:
    model = Sequential()
    model.add(LSTM(numOfUnits, return_sequences=False, input_shape=(x_train.shape[1],1)))
    model.add(Dense(1, activation='relu'))
    model.compile(optimizer=setOptimizer, loss='mean_squared_error')
    return model
  except:
    print('Exception: LSTM could not be created')


def trainModel(model,setBatchSize, setEpochs, x_train, y_train):
  try:
    model.fit(x_train, y_train, batch_size=setBatchSize, epochs=setEpochs,verbose=0)
  except:
    print('Exception: LSTM could not be trained')

def measureModelPerformance(x_test, y_test, model, scaler):
  try:
    predictions = model.predict(x_test)
    predictions = scaler.inverse_transform(predictions)
    rmse=np.sqrt(np.mean(((predictions- y_test)**2)))
    return rmse, predictions
  except:
    print('Exception: LSTM performance could not be measured')

def plotPerformance(data, training_data_len, predictions):
  try:
    train = data[:training_data_len]
    valid = data[training_data_len:]
    valid['Predictions'] = predictions
    plt.figure(figsize=(16,8))
    plt.title('Model')
    plt.xlabel('Date', fontsize=18)
    plt.ylabel('Close Price USD', fontsize=18)
    plt.plot(train['Close'])
    plt.plot(valid[['Close','Predictions']])
    plt.legend(['Train', 'Val', 'Predictions'], loc='lower right')
  except:
    print('Exception: LSTM performance could not be plotted')

def plotRMSEPerformance(y_rmse, x_rmse_date):
  try:
    plt.figure(0)
    plt.figure(figsize=(16, 8))
    plt.title('RMSE measured on date')
    plt.xlabel('Date', fontsize=18)
    plt.ylabel('Standard LSTM Model RMSE', fontsize=18)
    plt.plot_date(x_rmse_date, y_rmse, linestyle='-', marker=None)
    plt.gcf().autofmt_xdate()
    plt.show()
  except:
    print('Exception: RMSE performance could not be plotted by date')


def createModelAndMeasurePerformance( stockName,sliding_window_length,numOfUnits,setOptimizer,setBatchSize,setEpochs):
    scaler = MinMaxScaler(feature_range=(0,1))
    df = loadFromFile(stockName)
    data = filterDataOnClosingPrice(df)
    dataset = getValuesFromDataFrame(data)
    scaled_data = scaleDataset(dataset, scaler)
    training_data_len = defineTrainingDataLength(dataset)
    x_train, y_train, x_test, y_test = createTraingAndTestDataWithSlidingWindow(dataset, scaled_data, sliding_window_length, training_data_len)
    model = createLSTMModel(x_train,numOfUnits,setOptimizer)
    trainModel(model,setBatchSize, setEpochs, x_train, y_train)
    rmse, predictions = measureModelPerformance(x_test, y_test, model, scaler)
    return rmse

def testModel(stockName):
  sliding_window_length = 30
  numOfUnits = 50
  setBatchSize = 1
  setEpochs = 1
  try:
    start_time = time.time()
    rmse = createModelAndMeasurePerformance( stockName,sliding_window_length, numOfUnits, 'adam',setBatchSize, setEpochs)
    print((time.time() - start_time))
    print('Best RMSE: ' + str(rmse))
  except:
    print("Train model failed")

def main():
  testModel('./SPmax.csv')

if __name__ == "__main__":
    main()

